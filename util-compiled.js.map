{"version":3,"sources":["util.js"],"names":[],"mappings":"AAAA;;;AAGA;AACA,MAAM,OAAO,QAAQ,MAAR,CAAb;AACA,SAAS,MAAT,GAAiB;AACb,SAAK,IAAL,GAAY,KAAZ;AACA,SAAK,GAAL,GAAW,EAAX;AACA,SAAK,QAAL,GAAgB,YAAU;AACtB,gBAAQ,GAAR,CAAY,OAAZ;AACH,KAFD;AAGH;AACD,OAAO,SAAP,CAAiB,OAAjB,GAA2B,YAAU;AACjC,YAAQ,GAAR,CAAY,KAAK,IAAjB;AACH,CAFD;AAGA,SAAS,IAAT,GAAe;AACX,SAAK,IAAL,GAAY,MAAZ;AACH;AACD,KAAK,QAAL,CAAc,IAAd,EAAmB,MAAnB,E,CAA2B;AAC3B,IAAI,IAAI,IAAI,IAAJ,EAAR;AACA,EAAE,OAAF;AACA;AACA;AACA,QAAQ,GAAR,CAAY,KAAK,OAAL,CAAa,CAAb,CAAZ;AACA,QAAQ,GAAR,CAAY,EAAE,GAAd,E,CAAmB;AACnB;;AAEA,IAAI,IAAI,IAAI,MAAJ,EAAR;AACA,EAAE,OAAF;;AAEA,IAAI,SAAS,CAAC,KAAD,EAAO,MAAP,CAAb;AACA;AACA,QAAQ,GAAR,CAAY,KAAK,OAAL,CAAa,MAAb,CAAZ,E,CAAkC;AAClC;AACA;AACA","file":"util-compiled.js","sourcesContent":["/**\r\n * Created by lea on 2017/11/3.\r\n */\r\n//1、util.inherits(constructor, superConstructor):实现对象间原型继承 的函数。\r\nconst util = require(\"util\");\r\nfunction People(){\r\n    this.name = \"lea\";\r\n    this.age = 22;\r\n    this.sayHello = function(){\r\n        console.log(\"hello\");\r\n    };\r\n}\r\nPeople.prototype.getName = function(){\r\n    console.log(this.name);\r\n};\r\nfunction John(){\r\n    this.name = \"John\";\r\n}\r\nutil.inherits(John,People);//实现对象间 原型继承 的函数。\r\nlet j = new John();\r\nj.getName();\r\n//util.inspect():\r\n//一个将任意对象 转换 为字符串的方法，通常用于调试和错误输出\r\nconsole.log(util.inspect(j));\r\nconsole.log(j.age);//undefined [未继承]\r\n//j.sayHello();//报错了：inherits（）：仅仅继承了在原型中定义的函数，而在构造函数内创造的属性和函数都没有被继承。\r\n\r\nlet p = new People();\r\np.getName();\r\n\r\nlet ageArr = [\"lea\",\"john\"];\r\n//util.isArray(参数)：参数是数组返回true,否则返回false\r\nconsole.log(util.isArray(ageArr));//\r\n//util.isRegExp(参数):是否是正则表达式\r\n//util.isDate(参数 ):是否是一个日期\r\n//util.isError(参数)：是否是一个错误对象\r\n\r\n\r\n\r\n"]}